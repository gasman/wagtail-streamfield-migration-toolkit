
# Contents

- [Installation Notes](#installation-notes)
- [Basic Usage](#basic-usage)
- [Using Operations and Block Paths Properly](#using-operations-and-block-paths-properly)
  - [Block Path](#block-path)
  - [Rename and Remove Operations](#rename-and-remove-operations)
  - [Alter Block Structure Operations](#alter-block-structure-operations)
  - [Other Operations](#other-operations)
- [Making Custom Operations](#making-custom-operations)
  - [Basic Usage](#basic-usage)
  - [block_value](#blockvalue)
  - [Making Structural Changes](#making-structural-changes)
  - [Old List Format](#old-list-format)

# Installation Notes

- **For now we only support Wagtail 4**

- Note that the migration operation `MigrateStreamData` is dependent on the migrations of wagtailcore.
If a data migration containing `MigrateStreamData` is applied before the wagtailcore migrations have
been applied, you may get an error. (This may happen in wagtail 4 projects, and the
required migration is 0070_rename_pagerevision_revision.py)

# Basic Usage

Assume we have a model `BlogPage` in app `blog`, defined as follows:

```python
class BlogPage(Page):
    content = StreamField([
        ("stream1", blocks.StreamBlock([
            ("field1", blocks.CharBlock())
        ])),
    ])
```

If we want to rename `field1` to `block1`, even though we change the name to `block1` in our 
streamfield definitions, the actual data in the database does not reflect that. To update that data, 
we need to create a data migration which will update the data in the database to also have `block1` 
instead of `field1`.

First we create an empty migration file within the app. We can use django's `makemigrations` for 
this,

```
python manage.py makemigrations --empty blog
```

which will generate an empty migration file which looks like this

```python
# Generated by Django 4.0.3 on 2022-09-09 21:33

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [...]

    operations = [
    ]
```

We need to make sure that either this migration or one of the migrations it depends upon has the
wagtail core migrations as a dependency, since the package needs the migrations for the `Revision`
models to be able to run.

```python
    dependencies = [
        ('wagtailcore', '0076_modellogentry_revision'),
        ...
    ]
```

Next we need a migration operation which django will run to make our changes. If we weren't using
this package we would use a `migrations.RunPython` operation, and we would define what data 
(model, field etc.) we want and how we want to change that data in its forward (function) argument. 

Instead, we have a `migrate_operation.MigrateStreamData` operation which will handle accessing the
relevant data for us from the model streamfield. We need to specify the app name, model name and 
field name for the relevant streamfield as shown below.

```python
from django.db import migrations

from wagtail_streamfield_migration_toolkit.migrate_operation import MigrateStreamData

class Migration(migrations.Migration):

    dependencies = [...]

    operations = [
        MigrateStreamData(
            app_name="blog",
            model_name="BlogPage",
            field_name="content",
            operations_and_block_paths=[...]
        ),
    ]
```

In a streamfield, accessing just the field is not enough, since we will typically need to operate
on a specific block type/s. For this, we define a block path which points to that specific block
path within the streamfield to obtain the specific data we need. Finally, we define an operation
to update that data. As such we have an `(IntraFieldOperation(), 'block_path')` tuple. We can have
as many as these as we like in our `operations_and_block_paths`, but for now we'll look at a single
one for our rename operation.

In this case the block that we are operating on is `stream1`, the parent of the block being renamed
( refer [RenameStreamChildrenOperation](./REFERENCE.md/#renamestreamchildrenoperation-objects); for 
rename and remove operations we always operate on the parent block ). In that case our block path 
will be `stream1`. Next we need a function which will update our data. For this, the package has a 
set of commonly used intra field operations available (and it is possible to write 
[custom](#making-custom-operations)). Since this is a rename operation which operates on a 
streamfield, we will use `operations.RenameStreamChildrenOperation` which accepts two arguments as 
the old block name and the new block name. As such our operation and block path tuple will look like,

```python
(RenameStreamChildrenOperation(old_name="field1", new_name="block1"), "stream1")
```

And our final code will be,

```python
from django.db import migrations

from wagtail_streamfield_migration_toolkit.migrate_operation import MigrateStreamData
from wagtail_streamfield_migration_toolkit.operations import RenameStreamChildrenOperation

class Migration(migrations.Migration):

    dependencies = [
        ...
    ]

    operations = [
        MigrateStreamData(
            app_name="blog",
            model_name="BlogPage",
            field_name="content",
            operations_and_block_paths=[
                (RenameStreamChildrenOperation(old_name="field1", new_name="block1"), "stream1"),
            ]
        ),
    ]

```

# Using Operations and Block Paths Properly

The `MigrateStreamData` class takes a list of operations and corresponding block paths as a 
parameter `operations_and_block_paths`. Each operation in the list will be applied to all blocks
that match the corresponding block path.

```
operations_and_block_paths=[ 
    (operation1, block_path1),
    (operation2, block_path2),
    ... 
]
```

## Block Path

The block path is a `'.'` separated list of names of the block types from the top level StreamBlock (
the container of all the blocks in the StreamField) to the nested block type which will be matched 
and passed to the operation.

**NOTE:** If we want to directly operate on the top level StreamBlock, then the block path must be
an empty string `""`.

For example if our Stream definition looks like this,

```python
class MyDeepNestedBlock(StreamBlock):
    foo = CharBlock()
    date = DateBlock()

class MyNestedBlock(StreamBlock): 
    char1 = CharBlock()
    deepnested1 = MyDeepNestedBlock()

class MyStreamBlock(StreamBlock):
    field1 = CharBlock()
    nested1 = MyNestedBlock()

class MyPage(Page):
    content = StreamField(MyStreamBlock)
```

If we want to match all "field1" blocks, our block path will be `"field1"`,

```
[
    { "type": "field1", ... }, # this is matched
    { "type": "field1", ... }, # this is matched
    { "type": "nested1", "value": [...] },
    { "type": "nested1", "value": [...] },
    ...
]
```

If we want to match all "deepnested1" blocks, which are a direct child of "nested1", our block path
will be `"nested1.deepnested1"`,

```python
[
    { "type": "field1", ... },
    { "type": "field1", ... },
    { "type": "nested1", "value": [
        { "type": "char1", ... },
        { "type": "deepnested1", ... }, # This is matched
        { "type": "deepnested1", ... }, # This is matched
        ...
    ] },
    { "type": "nested1", "value": [
        { "type": "char1", ... },
        { "type": "deepnested1", ... }, # This is matched
        ...
    ] },
    ...
]
```

**NOTE**: When the path contains a ListBlock child, 'item' must be added to the block path as
the name of said child. For example, if we consider the following stream definition,

```
class MyStructBlock(StructBlock): 
    char1 = CharBlock()
    char2 = CharBlock()

class MyStreamBlock(StreamBlock):
    list1 = ListBlock(MyStructBlock())
```

Then if we want to match "char1", which is a child of the structblock which is the direct list 
child, we have to use `block_path_str="list1.item.char1"` instead of 
~~`block_path_str="list1.char1"`~~. We can also match the ListBlock child as such if we want with 
`block_path_str="list1.item"`.

## Rename and Remove Operations

The following operations are available from the package for renaming and removing blocks.

- `operations.RenameStreamChildrenOperation`
- `operations.RenameStructChildrenOperation`
- `operations.RemoveStreamChildrenOperation`
- `operations.RemoveStructChildrenOperation`

Note that all of these operations operate on the value of the parent block of the block which must
be removed or renamed. Hence make sure that the block path you are passing points to the parent 
block when using these operations. (see the example in [basic usage](#basic-usage))

## Alter Block Structure Operations

The following operations allow you to alter the structure of blocks in certain ways.

- `operations.StreamChildrenToListBlockOperation`  
    Operates on the value of a StreamBlock. Combines all child blocks of type `block_name` as 
    children of a single ListBLock which is a child of the parent StreamBlock.
- `operations.StreamChildrenToStreamBlockOperation`  
    Operates on the value of a StreamBlock. Note that `block_names` here is a list of block types 
    and not a single block type unlike `block_name` in the previous operation. Combines each child
    block of a type in `block_names` as children of a single StreamBlock which is a child of the 
    parent StreamBlock. 
- `operations.StreamChildrenToStructBlockOperation`  
    Moves each StreamBlock child of the given type inside a new StructBlock

    A new StructBlock will be created as a child of the parent StreamBlock for each child block of
    the given type, and then that child block will be moved from the parent StreamBlocks children
    inside the new StructBlock as a child of that StructBlock.
    
    For example, consider the following StreamField definition,

    ```
    mystream = StreamField([("char1", CharBlock()) ...], ...)
    ```

    Then the stream data would look like the following,

    ```
    [
        { "type": "char1", "value": "Value1", ... },
        { "type": "char1", "value": "Value2", ... },
        ...
    ]
    ```

    And if we define the operation like this,

    ```
    StreamChildrenToStructBlockOperation("char1", "struct1")
    ```

    Our altered stream data would look like this,

    ```
    [
        ...
        { "type": "struct1", "value": { "char1": "Value1" } },
        { "type": "struct1", "value": { "char1": "Value2" } },
        ...
    ]
    ```

    **NOTE:** Block ids are not preserved here since the new blocks are structurally different than 
    the previous blocks.


## Other Operations

- `operations.AlterBlockValueOperation`

# Making Custom Operations

## Basic Usage

While this package comes with a set of operations for common use cases, there may be many
instances where you need to define your own operation for mapping data. Making a custom operation
is fairly straightforward. All you need to do is extend the `BaseBlockOperation` class and 
define the `apply` method. 

For example, if we want to truncate the string in a `CharBlock` to a given length,

```python
from wagtail_streamfield_migration_toolkit.operations import BaseBlockOperation

class MyBlockOperation(BaseBlockOperation):
    def __init__(self, length):
        super().__init__()
        # we will need to keep the length as an attribute of the operation
        self.length = length
        
    def apply(self, block_value):
        # block value is the string value of the CharBlock
        new_block_value = block_value[:self.length]
        return new_block_value

```

## block_value

Note that depending on the type of block we're dealing with, the `block_value` which is passed to
`apply` may take different structures.

For non structural blocks, the value of the block will be passed directly. For example, if we're
dealing with a `CharBlock`, it will be a string value.

The value passed to `apply` when the matched block is a StreamBlock would look like this,

```JSON
[
    { "type": "...", "value": "...", "id": "..." },
    { "type": "...", "value": "...", "id": "..." },
    ...
]
```

The value passed to `apply` when the matched block is a StructBlock would look like this,

```JSON
{
    "type1": "...",
    "type2": "...",
    ...
}
```

The value passed to `apply` when the matched block is a ListBlock would look like this,

```JSON
[
    { "type": "item", "value": "...", "id": "..." },
    { "type": "item", "value": "...", "id": "..." },
    ...
]
```

## Making Structural Changes

When making changes involving the structure of blocks (eg: changing block type), it may be needed
to operate on the block value of the parent block instead of the block to which the change is made,
since only the value of a block is changed by the `apply` operation.

Take a look at the implementation of the `RenameStreamChildrenOperation` for an example.

## Old list format

Prior to wagtail version 2.16 list block children were saved as just a normal python list of values. 
However for newer versions of wagtail, list block children are saved as ListValues. When handling
raw data, the changes would like the following,

old format

```python
[
    value1,
    value2,
    ...
]
```

new format

```python
[
    { "type": "item", "id": "...", "value": value1 },
    { "type": "item", "id": "...", "value": value2 },
    ...
]
```

When defining an operation that operates on a ListBlock value, in case you have old data which is
still in the old format, it is possible to use 
`wagtail_streamfield_migration_toolkit.utils.formatted_list_child_generator` to obtain the children
in the new format like so,

```python
    def apply(self, block_value):
        for child_block in formatted_list_child_generator(list_block_value):
            ...
```